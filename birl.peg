// BIRL Grammar
// ==========================
// Generated for peg.js
//

program
  = bl* begin_program ws* bl program:(expression)* end_program bl*
  {
    return {
      type: 'File',
      program: {
        type: 'Program',
        body: program,
      },
    }
}


// TOMA ESSES PESOS SEU MERDA
// Types
// ==========================
//

begin_program = 'HORA DO SHOW'
end_program = 'BIRL'
char_type = 'FRANGO'
short_type = 'MONSTRINHO'
int_type = 'MONSTRO'
long_type = 'MONSTRAO'
float_type = 'TRAPEZIO'
double_type = 'TRAPEZIO DESCENDENTE'
unsigned_type = 'BICEPS MONSTRO' // Only unsigned int

types
 = (begin_program /
    end_program /
    char_type /
    short_type /
    int_type /
    long_type /
    float_type /
    double_type /
    unsigned_type)

// TOMA ESSA FUNÇÃO SEU FRANGO!
// Standard functions
// ==========================
//
print_func
  = 'CE QUER VER ESSA PORRA?'

standard_functions
  = (print_func)

// NÃO É ÁGUA COM MÚSCULO
// Useless tokens
// ==========================
//

function_pre_call
  = 'AJUDA O MALUCO TA DOENTE'

function_pre_declaration
  = 'OH O HOME AI PO'

birl
  = 'BIRL'

// DERRUBAR ARVORE NO IBIRAPUERA
// function tokens
// ==========================
//

return_expression
  = ident* 'BORA CUMPADI' ws+ return_expression:(expression / var_identifier) ws* bl?
  {
    return {
      type: 'ReturnStatement',
      argument: return_expression,
    }
  }

call_args
 = (operation / variable_name / value)

arg_list
  = head:call_args tail:(ws? ',' ws? call_args)*
  {
    var array = [head]
    for (var t in tail) {
        array.push(tail[t][3])
    }
    return array
  }

standard_function_call
  = function_name:standard_functions ws* '(' ws* args:arg_list ws* ')'
  {
    /* VIRA console.log MONSTRAO */
    return {
      type: 'CallExpression',
      arguments: args,
      callee: {
        type: 'MemberExpression',
        object: {
          type: 'Identifier',
          name: 'console',
        },
        property: {
          type: 'Identifier',
          name: 'log',
        },
      },
    }
  }

function_call
  = function_pre_call ws callee:var_identifier '(' args:arg_list ')'
  {
    return {
      type: 'CallExpression',
      callee,
      arguments: args,
    }
  }

arg_declaration_list
  = head:( types ws+ var_identifier) tail:(ws* ',' ws+ types ws var_identifier)* ws*
  {
    var array = [head[2]]
    for (var t in tail) {
        const arg = tail[t];
        array.push(arg[5]);
    }
    return array
  }

function_declaration
  = function_pre_declaration ws+ types ws+ function_identifier:var_identifier ws* '(' params:arg_declaration_list ')' ws* bl
    ident* body:mandatory_block
    ident* birl
  {
    return {
      type: 'FunctionDeclaration',
      id: function_identifier,
      params,
      body,
    }
  }

// ELE QUE A GENTE QUER
// if expressions
// ==========================
//

condition_expressions = (
  operation /
  function_call /
  variable_name /
  value
)

mandatory_block
  = head:(inner_block_expressions) bl* tail:(inner_block_expressions)* bl*
  {
    const block_expressions = [head];
    for (var t in tail) {
      block_expressions.push(tail[t]);
    }
    return {
      type: 'BlockStatement',
      body: block_expressions,
    };
  }

else_if_block
  = ident* 'QUE NAO VAI DAR O QUE?' ws+ test:condition_expressions ws* bl
    ident* block:mandatory_block
    ident* alternate:(else_block /else_if_block)?
  {
    return {
      type: 'IfStatement',
      test,
      consequent: block,
      alternate,
    }
  }

else_block
  = ident* 'NAO VAI DAR NAO' ws* bl
    ident* block:mandatory_block
  {
    return block
  }

if_expression =
    ident* 'ELE QUE A GENTE QUER?'
    ws+ test:condition_expressions ws* bl
    ident* consequent:(mandatory_block)
    alternate:(else_block / else_if_block)?
    ident* birl
    { return {
        type: 'IfStatement',
        test,
        consequent,
        alternate,
      }
    }

// OS EXERCICIOS SEU FRANGO
// operations
// ==========================
//

sum_operator = '+'
minus_operator = '-'
mult_operator = '*'
division_operator = '/'
lt_operator = '<'
lte_operator = lt_operator '='
gt_operator = '>'
gte_operator = gt_operator '='
equal_operator = '=='
nequal_operator = '!='
or_operator = '||'
and_operator = '&&'

operators
  = (
    sum_operator /
    minus_operator /
    mult_operator /
    division_operator /
    lt_operator /
    lte_operator /
    gt_operator /
    gte_operator /
    equal_operator /
    nequal_operator /
    or_operator /
    and_operator
 )

operands = (value / var_identifier)

operation_expression = op:operation
  {
    return op
  }

open_parenthesis = '('
close_parenthesis = '('

operation
  = open_parenthesis? op:operation_terminal close_parenthesis?
  {
    return op;
  }

operation_terminal
  = o1:operands ws? operator:operators ws? o2:(operation / operands) ws?
  {
    return {
      type: 'BinaryExpression',
      left: o1,
      operator,
      right: o2,
    }
  }

// BORA DE NOVO PORRA
// loops
// ==========================
//

continue = 'VAMO MONSTRO' { return 'continue' }
break = 'SAI FILHO DA PUTA' { return 'break' }

for_block
  = head:(inner_block_expressions) tail:(inner_block_expressions)*
  {
    const block_expressions = [head];
    for (var t in tail) {
      block_expressions.push(tail[t]);
    }
    return block_expressions;
  }

for_loop
  = 'MAIS QUERO MAIS' '('
    counter:(var_attribution / var_declaration) ws* ';'
    ws* condition:condition_expressions ws* ';'
    ws* counter_diff:operation ws* ')' bl*
    ident* block:for_block
    ident* birl
  {
    return {
      counter,
      condition,
      counter_diff,
      block,
    }
  }

while_loop
  = 'NEGATIVA BAMBAM' '('condition:condition_expressions ')' ws* bl
    ident* block:for_block
    ident* birl
  {
    return {
        token_name: 'while',
        condition,
        block,
    }
  }

// BIRRRLLL É TREZE PORRA
// values and expression
// ==========================
//

inner_block_expressions = block:(continue / break / return_expression / expression) bl?
  {
    return block
  }

expression_statement = expression:(
    operation_expression /
    var_attribution /
    value /
    function_call /
    standard_function_call
  )
  {
    return {
      type: 'ExpressionStatement',
      expression,
    }
  }

// Expression is probably overused, migrating to expression_statement
expression
  = ident:ident* expression:(
    expression_statement /
    for_loop /
    var_declaration /
    function_call /
    function_declaration /
    if_expression
  ) bl?
  {
    return expression;
  }
value
  = (string / number)

array_separator
  = ',' {return ''}

array
  = '[' head:value tail:(array_separator value)* ']'
  {
    var array = [head]
    for (var t in tail) {
        array.push(tail[t][1])
    }
    return array
  }

iterable
  = array

var_values
  = (value / operation / function_call)

attribution_operators = ('=' / '-=' / '+=')

var_attribution
  = var_identifier:var_identifier ws* operator:(attribution_operators) ws* value:var_values
  {
    return {
      type: 'AssignmentExpression',
      operator,
      left: var_identifier,
      right: value,
    }
  }


var_declaration
  = type:types ws variable_name:variable_name ws* '=' ws* value:var_values
  {
    return {
      type: 'VariableDeclaration',
      kind: 'var',
      declarations: [
        {
          type: 'VariableDeclarator',
          id: {
            type: 'Identifier',
            name: variable_name,
          },
          init: value,
        }
      ]
    }
  }

var_identifier
  = variable_name:variable_name
  {
    return {
      type: 'Identifier',
      name: variable_name,
    }
  }

ident
  = '  '

variable_name
  = head:[a-zA-Z-_]+ tail:[a-zA-Z0-9-_]* { return head.concat(tail).join("") }

string
  = quotation_mark chars:char* quotation_mark
  {
    return {
      type: 'StringLiteral',
      value: chars.join(""),
    };
  }

number = num:[0-9]+ {
  return {
    type: 'NumericLiteral',
    value: parseInt(num.join(""), 10),
  }
}

char
  = unescaped
  / escape
    sequence:(
        '"'
      / "\\"
      / "/"
      / "b" { return "\b"; }
      / "f" { return "\f"; }
      / "n" { return "\n"; }
      / "r" { return "\r"; }
      / "t" { return "\t"; }
      / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape         = "\\"
quotation_mark = '"'
single_quotation_mark = "'"
unescaped      = [\x20-\x21\x23-\x5B\x5D-\u10FFFF]
HEXDIG = [0-9a-f]i
bl = [\n]+ { return 'break_line' }
ws = [ \t\r]+ { return 'space'}
